<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PicoCrypt FPV - Complete Project Guide</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #34495e;
            --accent-color: #e74c3c;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --info-color: #3498db;
            --light-bg: #ecf0f1;
            --dark-bg: #2c3e50;
            --text-primary: #2c3e50;
            --text-secondary: #7f8c8d;
            --border-color: #bdc3c7;
            --code-bg: #f8f9fa;
            --code-border: #e9ecef;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background-color: #ffffff;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 3rem 0;
            text-align: center;
            margin-bottom: 3rem;
        }

        h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            font-weight: 300;
        }

        .phase {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 3rem;
            overflow: hidden;
            border-left: 5px solid var(--accent-color);
        }

        .phase-header {
            background: var(--light-bg);
            padding: 2rem;
            border-bottom: 1px solid var(--border-color);
        }

        .phase-title {
            font-size: 2rem;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .phase-icon {
            font-size: 2.5rem;
            color: var(--accent-color);
        }

        .phase-content {
            padding: 2rem;
        }

        .section {
            margin-bottom: 2.5rem;
        }

        .section h3 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--secondary-color);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--accent-color);
        }

        .component-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin: 1.5rem 0;
        }

        .component-card {
            background: var(--light-bg);
            border-radius: 8px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
            transition: transform 0.2s ease;
        }

        .component-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .component-name {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }

        .component-specs {
            font-size: 0.9rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .code-block {
            background: var(--code-bg);
            border: 1px solid var(--code-border);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            overflow-x: auto;
        }

        .circuit-diagram {
            background: white;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 2rem;
            margin: 1.5rem 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            line-height: 1.2;
            overflow-x: auto;
            text-align: center;
        }

        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid var(--warning-color);
        }

        .info-box {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid var(--info-color);
        }

        .success-box {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid var(--success-color);
        }

        .download-section {
            background: var(--dark-bg);
            color: white;
            padding: 3rem 0;
            text-align: center;
            margin-top: 3rem;
        }

        .download-btn {
            display: inline-block;
            background: var(--accent-color);
            color: white;
            padding: 1rem 2rem;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 600;
            margin: 0.5rem;
            transition: background 0.3s ease;
        }

        .download-btn:hover {
            background: #c0392b;
            color: white;
        }

        .toc {
            background: var(--light-bg);
            border-radius: 8px;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 1px solid var(--border-color);
        }

        .toc h2 {
            margin-bottom: 1rem;
            color: var(--primary-color);
        }

        .toc ul {
            list-style: none;
        }

        .toc li {
            margin: 0.5rem 0;
        }

        .toc a {
            color: var(--info-color);
            text-decoration: none;
            font-weight: 500;
        }

        .toc a:hover {
            text-decoration: underline;
        }

        .highlight {
            background: linear-gradient(120deg, #ffeaa7 0%, #fab1a0 100%);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .phase-title {
                font-size: 1.5rem;
            }
            
            .component-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1><i class="fas fa-shield-alt"></i> PicoCrypt FPV</h1>
            <p class="subtitle">Open-Source FPV Video Encryption System with Raspberry Pi Pico</p>
        </div>
    </header>

    <div class="container">
        <div class="toc">
            <h2><i class="fas fa-list"></i> Table of Contents</h2>
            <ul>
                <li><a href="#phase1">Phase 1: Hardware Design and Component Selection</a></li>
                <li><a href="#phase2">Phase 2: Proof of Concept 1 - Video Output</a></li>
                <li><a href="#phase3">Phase 3: Proof of Concept 2 - Video Input</a></li>
                <li><a href="#phase4">Phase 4: Real-time Passthrough</a></li>
                <li><a href="#phase5">Phase 5: White Noise Stream Cipher</a></li>
                <li><a href="#phase6">Phase 6: Final System Integration</a></li>
            </ul>
        </div>

        <div id="phase1" class="phase">
            <div class="phase-header">
                <h2 class="phase-title">
                    <i class="fas fa-microchip phase-icon"></i>
                    Phase 1: Hardware Design and Component Selection
                </h2>
                <p>Basic hardware components and circuit design for the PicoCrypt FPV System</p>
            </div>
            <div class="phase-content">
                <div class="section">
                    <h3>1.1 Core Components and Specifications</h3>
                    
                    <div class="component-grid">
                        <div class="component-card">
                            <div class="component-name"><i class="fas fa-microchip"></i> Raspberry Pi Pico (RP2040)</div>
                            <div class="component-specs">
                                <strong>CPU:</strong> Dual-Core ARM Cortex-M0+ @ 133MHz<br>
                                <strong>RAM:</strong> 264KB SRAM<br>
                                <strong>Flash:</strong> 2MB<br>
                                <strong>GPIO:</strong> 26 Pins, 3.3V Logic<br>
                                <strong>Features:</strong> 8x PIO State Machines, DMA Controller
                            </div>
                        </div>

                        <div class="component-card">
                            <div class="component-name"><i class="fas fa-wave-square"></i> Flash-ADC (e.g., AD9280)</div>
                            <div class="component-specs">
                                <strong>Type:</strong> 8-bit Parallel Flash ADC<br>
                                <strong>Sampling Rate:</strong> Min. 10 MS/s<br>
                                <strong>Resolution:</strong> 8-bit (256 levels)<br>
                                <strong>Input:</strong> 1Vpp Analog<br>
                                <strong>Interface:</strong> Parallel 8-bit output<br>
                                <strong>Recommended:</strong> AD9280, AD9288
                            </div>
                        </div>

                        <div class="component-card">
                            <div class="component-name"><i class="fas fa-wave-square"></i> R-2R Resistor Ladder</div>
                            <div class="component-specs">
                                <strong>Type:</strong> 8-bit R-2R Network<br>
                                <strong>Resistors:</strong> R = 10kΩ, 2R = 20kΩ<br>
                                <strong>Accuracy:</strong> 0.1% or better<br>
                                <strong>Material:</strong> Metal film resistors<br>
                                <strong>Alternative:</strong> Integrated R-2R DAC IC
                            </div>
                        </div>

                        <div class="component-card">
                            <div class="component-name"><i class="fas fa-bolt"></i> Operational Amplifier</div>
                            <div class="component-specs">
                                <strong>Type:</strong> Video Operational Amplifier<br>
                                <strong>Bandwidth:</strong> >100MHz<br>
                                <strong>Slew Rate:</strong> >1000V/μs<br>
                                <strong>Recommended:</strong> LMH6702, CLC409<br>
                                <strong>Function:</strong> Signal conditioning, Buffer
                            </div>
                        </div>
                    </div>

                    <div class="info-box">
                        <strong><i class="fas fa-info-circle"></i> Important Notes:</strong><br>
                        The choice of ADC is critical - it must offer at least a 10 MS/s sampling rate for PAL video (5MHz bandwidth). The R-2R DAC should use precision resistors (0.1% tolerance) to minimize linearity errors.
                    </div>
                </div>

                <div class="section">
                    <h3>1.2 Concept Schematic</h3>
                    
                    <div class="circuit-diagram">
                        <pre>
                                VIDEO INPUT (CVBS)
                                       |
                                       v
                            [AC Coupling Capacitor]
                                       |
                                       v
                            [Op-Amp Buffer/Amplifier]
                            (LMH6702 - Input Conditioning)
                                       |
                                       v
                            [DC Offset/Level Shifter]
                                       |
                                       v
                            [Anti-Aliasing Filter]
                                       |
                                       v
                            +---------------------+
                            |    Flash-ADC        |
                            |    (AD9280)         |
                            |                     |
                            | Analog In ------> Digital Out (8-bit)
                            |                     |
                            | CLK IN <----- PIO-GPIO |
                            +---------------------+
                                       |
                                       v
                            [RP2040 GPIO Input]
                            (8 parallel data lines)
                                       |
                                       v
                            +---------------------+
                            |   Raspberry Pi Pico |
                            |     (RP2040)        |
                            |                     |
                            | Core 0: Sync Detection |
                            | Core 1: Processing   |
                            | PIO: Timing Control  |
                            | DMA: Data Transfer   |
                            +---------------------+
                                       |
                                       v
                            [RP2040 GPIO Output]
                            (8 parallel data lines)
                                       |
                                       v
                            +---------------------+
                            |     R-2R DAC        |
                            |  (Resistor Ladder)  |
                            |                     |
                            | Digital In ------> Analog Out
                            | (8-bit)             |
                            +---------------------+
                                       |
                                       v
                            [Op-Amp Buffer/Filter]
                            (LMH6702 - Output Stage)
                                       |
                                       v
                            [Video Amplifier]
                            (75Ω Matching)
                                       |
                                       v
                                VIDEO OUTPUT
                        </pre>
                    </div>

                    <div class="warning-box">
                        <strong><i class="fas fa-exclamation-triangle"></i> Critical Connections:</strong><br>
                        - All 8 data lines must have equal length and run in parallel<br>
                        - Ground plane for minimal noise<br>
                        - Separate supplies for analog and digital circuits<br>
                        - Short traces between ADC and R-2R DAC
                    </div>
                </div>

                <div class="section">
                    <h3>1.3 Signal Conditioning and Op-Amp Circuits</h3>
                    
                    <h4>Input Stage (ADC Pre-amplifier):</h4>
                    <div class="code-block">
                        <pre>
Input Signal: CVBS (1Vpp, 75Ω system)
    |
    +--[DC-Block C1]--+--[R1]--+--[Op-Amp (+)]--+
    |                 |        |               |
    |                 +--[R2]--+               |
    |                                        [R3]--[GND]
    |                                        |
    +----------------------------------------+
    |
    v
Adjusted Signal (0-1V for ADC)

Components:
- C1: 10μF Ceramic (DC decoupling)
- R1, R2: 1kΩ (Input divider)
- R3: 1kΩ (Bias resistor)
- Op-Amp: LMH6702 (1.7GHz Bandwidth)
                        </pre>
                    </div>

                    <h4>Output Stage (DAC Buffer):</h4>
                    <div class="code-block">
                        <pre>
R-2R DAC Output
    |
    +--[Op-Amp (+)]--+--[R4]--+--[Video Out]
    |               |        |
    |               [R5]     [R6] (75Ω)
    |               |        |
    +--[Op-Amp (-)]--+        [GND]
    |
    v
Buffered Video Signal

Components:
- R4: 1kΩ (Series resistor)
- R5: 1kΩ (Feedback)
- R6: 75Ω (Matching to 75Ω system)
- Op-Amp: LMH6702 (80mA output current)
                        </pre>
                    </div>

                    <div class="info-box">
                        <strong><i class="fas fa-lightbulb"></i> Design Considerations:</strong><br>
                        The LMH6702 offers 1.7GHz bandwidth and a 3100V/μs slew rate, which is optimal for video applications. The 80mA output current is sufficient for 75Ω loads. A separate ground plane for analog and digital signals is important.
                    </div>
                </div>
            </div>
        </div>

        <div id="phase2" class="phase">
            <div class="phase-header">
                <h2 class="phase-title">
                    <i class="fas fa-play phase-icon"></i>
                    Phase 2: Proof of Concept 1 - Video Output
                </h2>
                <p>Generating a stable CVBS test pattern with R-2R DAC and PIO timing</p>
            </div>
            <div class="phase-content">
                <div class="section">
                    <h3>2.1 Goal and Architecture</h3>
                    <p>Generate a stable color bar test pattern as a CVBS signal via an R-2R DAC. The PIO state machine handles the precise timing of H-Sync, V-Sync, and video data.</p>

                    <div class="success-box">
                        <strong><i class="fas fa-check-circle"></i> Success Criteria:</strong><br>
                        - Stable PAL/NTSC signal (25/30fps)<br>
                        - Correct sync pulses (4.7μs H-Sync, 160μs V-Sync)<br>
                        - Clean color bar generation<br>
                        - <20ms total latency
                    </div>
                </div>

                <div class="section">
                    <h3>2.2 PIO Program for Video Timing</h3>
                    <div class="code-block">
                        <pre>
; PIO program for video sync generation
; Generates H-Sync and V-Sync pulses according to PAL standard

.program video_sync
.side_set 1

; Constants for PAL video
H_SYNC_PULSE    = 96    ; 4.7μs at 20.25MHz
H_BACK_PORCH    = 48    ; 2.35μs
H_ACTIVE_VIDEO  = 640   ; 31.5μs
H_FRONT_PORCH   = 12    ; 0.6μs
V_SYNC_PULSE    = 5     ; 160μs
V_BACK_PORCH    = 36    ; 1.152ms
V_ACTIVE_LINES  = 576   ; 18.432ms
V_FRONT_PORCH   = 4     ; 128μs

start:
    ; Generate H-Sync pulse
    set pins, 0           ; Sync level (0V)
    set x, H_SYNC_PULSE   
hsync_loop:
    nop [31]              ; 1 clock execution
    jmp x--, hsync_loop   ; Loop for H-Sync duration
    
    ; Back Porch
    set pins, 1           ; Blank level (0.3V)
    set x, H_BACK_PORCH
back_porch_loop:
    nop [31]
    jmp x--, back_porch_loop
    
    ; Active Video Time
    set pins, 2           ; Video level (0.7V)
    set x, H_ACTIVE_VIDEO
video_loop:
    nop [31]
    jmp x--, video_loop
    
    ; Front Porch
    set pins, 1           ; Blank level
    set x, H_FRONT_PORCH
front_porch_loop:
    nop [31]
    jmp x--, front_porch_loop
    
    jmp start             ; Next line
                        </pre>
                    </div>
                </div>

                <div class="section">
                    <h3>2.3 C-Code for Test Pattern Generator</h3>
                    <div class="code-block">
                        <pre>
#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/dma.h"
#include "hardware/clocks.h"

// Video constants
#define VIDEO_WIDTH     720
#define VIDEO_HEIGHT    576
#define PIXEL_CLOCK     13500000  // 13.5MHz for PAL

// Color bar pattern (8-bit values for R-2R DAC)
const uint8_t color_bars[8] = {
    0xFF,  // White
    0xE0,  // Yellow
    0x1C,  // Cyan
    0x00,  // Green
    0x03,  // Magenta
    0x1F,  // Red
    0xFC,  // Blue
    0x80   // Black
};

// Initialize PIO program
void init_video_pio(PIO pio, uint sm) {
    uint offset = pio_add_program(pio, &video_sync_program);
    
    pio_sm_config c = video_sync_program_get_default_config(offset);
    
    // Set clock divider for 20.25MHz (PAL Pixel-Clock)
    float div = (float)clock_get_hz(clk_sys) / 20250000.0;
    sm_config_set_clkdiv(&c, div);
    
    // Configure GPIO pins
    sm_config_set_set_pins(&c, 0, 3);  // 3 pins for video level
    sm_config_set_sideset_pins(&c, 3); // 1 pin for H-Sync
    
    pio_gpio_init(pio, 0);
    pio_gpio_init(pio, 1);
    pio_gpio_init(pio, 2);
    pio_gpio_init(pio, 3);
    
    gpio_set_function(0, GPIO_FUNC_PIO0);
    gpio_set_function(1, GPIO_FUNC_PIO0);
    gpio_set_function(2, GPIO_FUNC_PIO0);
    gpio_set_function(3, GPIO_FUNC_PIO0);
    
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

// DMA configuration for video data
void init_video_dma(uint dma_chan, uint8_t* video_buffer) {
    dma_channel_config c = dma_channel_get_default_config(dma_chan);
    
    channel_config_set_transfer_data_size(&c, DMA_SIZE_8);
    channel_config_set_read_increment(&c, true);
    channel_config_set_write_increment(&c, false);
    
    // DMA trigger from PIO
    channel_config_set_dreq(&c, DREQ_PIO0_TX0);
    
    dma_channel_configure(
        dma_chan,
        &c,
        &pio0_hw->txf[0],  // PIO FIFO
        video_buffer,
        VIDEO_WIDTH * VIDEO_HEIGHT,
        false
    );
}

// Generate color bar pattern
void generate_color_bars(uint8_t* buffer) {
    for (int y = 0; y < VIDEO_HEIGHT; y++) {
        for (int x = 0; x < VIDEO_WIDTH; x++) {
            int bar_width = VIDEO_WIDTH / 8;
            int bar_index = x / bar_width;
            
            if (bar_index >= 8) bar_index = 7;
            
            buffer[y * VIDEO_WIDTH + x] = color_bars[bar_index];
        }
    }
}

int main() {
    stdio_init_all();
    
    // Allocate video buffer
    uint8_t* video_buffer = (uint8_t*)malloc(VIDEO_WIDTH * VIDEO_HEIGHT);
    
    // Generate color bars
    generate_color_bars(video_buffer);
    
    // Initialize PIO
    PIO pio = pio0;
    uint sm = 0;
    init_video_pio(pio, sm);
    
    // Initialize DMA
    uint dma_chan = dma_claim_unused_channel(true);
    init_video_dma(dma_chan, video_buffer);
    
    // Start DMA
    dma_channel_start(dma_chan);
    
    // Main loop
    while (true) {
        tight_loop_contents();
    }
    
    return 0;
}
                        </pre>
                    </div>

                    <div class="info-box">
                        <strong><i class="fas fa-cogs"></i> PIO Explanation:</strong><br>
                        The PIO state machine generates precise video timing without CPU intervention. The DMA system transfers video data directly from memory to the R-2R DAC line. The CPU is only responsible for initialization.
                    </div>
                </div>

                <div class="section">
                    <h3>2.4 Timing Calculations</h3>
                    <div class="code-block">
                        <pre>
PAL Video Timing (720x576 @ 25fps):

Line Duration: 64μs
- H-Sync: 4.7μs (96 Clocks @ 20.25MHz)
- Back Porch: 5.7μs (116 Clocks)
- Active Video: 52μs (1053 Clocks)
- Front Porch: 1.6μs (32 Clocks)

Frame Duration: 20ms (312.5 lines)
- V-Sync: 160μs (5 lines)
- Back Porch: 1.152ms (36 lines)
- Active Frame: 18.432ms (576 lines)
- Front Porch: 0.256ms (4 lines)

Pixel Clock: 13.5MHz (for 720 active pixels)
PIO Clock: 20.25MHz (for a complete line with sync)
                        </pre>
                    </div>
                </div>
            </div>
        </div>

        <div id="phase3" class="phase">
            <div class="phase-header">
                <h2 class="phase-title">
                    <i class="fas fa-eye phase-icon"></i>
                    Phase 3: Proof of Concept 2 - Video Input
                </h2>
                <p>ADC-based video signal acquisition and synchronization pulse detection</p>
            </div>
            <div class="phase-content">
                <div class="section">
                    <h3>3.1 Goal and Architecture</h3>
                    <p>Capture an analog CVBS signal via a Flash ADC and detect the video synchronization pulses for later encryption.</p>

                    <div class="warning-box">
                        <strong><i class="fas fa-exclamation-triangle"></i> Critical Requirements:</strong><br>
                        - Precise sync pulse detection (±0.1μs)<br>
                        - Minimal processing latency (<1μs)<br>
                        - Stable data acquisition at 10MS/s<br>
                        - Correct V-Sync resynchronization
                    </div>
                </div>

                <div class="section">
                    <h3>3.2 PIO Program for Sync Detection</h3>
                    <div class="code-block">
                        <pre>
; PIO program for video sync detection
; Detects H-Sync and V-Sync pulses from the ADC

.program video_sync_detect

; Sync detection state machine
start:
    ; Wait for video signal from ADC
    wait 0 pin 0        ; Wait for sync level
    
    ; H-Sync detection
    set x, 0
h_sync_measure:
    jmp pin, h_sync_end ; End of H-Sync reached
    jmp x--, h_sync_measure
    
h_sync_end:
    ; H-Sync duration stored in x
    mov isr, x
    push
    
    ; Wait for next signal
    wait 1 pin 0
    jmp start
    
    ; V-Sync detection (longer pulse)
    ; Will be checked by software
                        </pre>
                    </div>
                </div>

                <div class="section">
                    <h3>3.3 C-Code for Video Input</h3>
                    <div class="code-block">
                        <pre>
#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/dma.h"
#include "hardware/adc.h"

// Video input configuration
#define ADC_PIN         26      // ADC input
#define VIDEO_WIDTH     720
#define VIDEO_HEIGHT    576
#define SAMPLE_RATE     10000000 // 10MS/s

// Video sync structure
typedef struct {
    uint32_t h_sync_pos;
    uint32_t v_sync_pos;
    bool h_sync_detected;
    bool v_sync_detected;
    uint32_t line_counter;
} video_sync_t;

// Global variables
static video_sync_t video_sync;
static uint8_t video_line_buffer[VIDEO_WIDTH];
static uint8_t* current_line_ptr = video_line_buffer;

// ADC initialization
void init_adc(void) {
    adc_init();
    adc_gpio_init(ADC_PIN);
    adc_select_input(0);  // ADC channel 0
    
    // Set ADC to maximum speed
    adc_set_clkdiv(0);  // No divider = max speed
}

// DMA initialization for ADC data
void init_adc_dma(uint dma_chan, uint8_t* buffer) {
    dma_channel_config c = dma_channel_get_default_config(dma_chan);
    
    channel_config_set_transfer_data_size(&c, DMA_SIZE_8);
    channel_config_set_read_increment(&c, false);   // ADC FIFO is fixed
    channel_config_set_write_increment(&c, true);   // Increment buffer address
    
    // ADC FIFO as source
    channel_config_set_dreq(&c, DREQ_ADC);
    
    dma_channel_configure(
        dma_chan,
        &c,
        buffer,              // Destination buffer
        &adc_hw->fifo,       // ADC FIFO source
        VIDEO_WIDTH,         // Number of samples
        false                // Do not start yet
    );
}

// H-Sync interrupt handler
void h_sync_handler(void) {
    // New line begins
    video_sync.h_sync_detected = true;
    video_sync.line_counter++;
    
    // Start DMA for new line
    if (video_sync.line_counter < VIDEO_HEIGHT) {
        dma_channel_start(ADC_DMA_CHAN);
    }
}

// V-Sync interrupt handler
void v_sync_handler(void) {
    // New frame begins
    video_sync.v_sync_detected = true;
    video_sync.line_counter = 0;
    video_sync.v_sync_pos = time_us_32();
    
    // Reset PRNG for new encryption
    reset_encryption_prng();
}

// Video sync detection
void detect_video_sync(void) {
    // Use PIO for precise sync measurement
    PIO pio = pio0;
    uint sm = 0;
    
    // Load PIO program
    uint offset = pio_add_program(pio, &video_sync_detect_program);
    pio_sm_config c = video_sync_detect_program_get_default_config(offset);
    
    // Configure GPIO for sync input
    pio_gpio_init(pio, ADC_PIN);
    gpio_set_function(ADC_PIN, GPIO_FUNC_PIO0);
    
    // Configure state machine
    sm_config_set_in_pins(&c, ADC_PIN);
    sm_config_set_jmp_pin(&c, ADC_PIN);
    
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

// Main processing loop
void video_input_loop(void) {
    while (true) {
        // Wait for H-Sync
        if (video_sync.h_sync_detected) {
            video_sync.h_sync_detected = false;
            
            // Process received line
            process_video_line(video_line_buffer, VIDEO_WIDTH);
            
            // Reset line buffer pointer
            current_line_ptr = video_line_buffer;
        }
        
        // V-Sync handling
        if (video_sync.v_sync_detected) {
            video_sync.v_sync_detected = false;
            handle_new_frame();
        }
    }
}

// Process video line
void process_video_line(uint8_t* line_data, uint length) {
    // Encryption will be added here later
    // Currently: Direct passthrough to output
    
    // Wait for output buffer
    while (!output_buffer_ready());
    
    // Copy data to output buffer
    memcpy(output_buffer, line_data, length);
    output_buffer_ready_flag = false;
}

int main() {
    stdio_init_all();
    
    // Initializations
    init_adc();
    init_adc_dma(ADC_DMA_CHAN, video_line_buffer);
    detect_video_sync();
    
    // Start video input
    video_input_loop();
    
    return 0;
}
                        </pre>
                    </div>
                </div>

                <div class="section">
                    <h3>3.4 DMA Streaming for Real-time Processing</h3>
                    <div class="code-block">
                        <pre>
// Double-buffer configuration for seamless processing
typedef struct {
    uint8_t buffer_a[VIDEO_WIDTH];
    uint8_t buffer_b[VIDEO_WIDTH];
    uint8_t* active_buffer;
    uint8_t* processing_buffer;
    bool buffer_a_ready;
    bool buffer_b_ready;
} double_buffer_t;

static double_buffer_t video_buffers;

// Double-buffer initialization
void init_double_buffer(void) {
    video_buffers.active_buffer = video_buffers.buffer_a;
    video_buffers.processing_buffer = video_buffers.buffer_b;
    video_buffers.buffer_a_ready = false;
    video_buffers.buffer_b_ready = false;
}

// DMA transfer complete interrupt
void dma_transfer_complete(void) {
    // Swap buffers
    if (video_buffers.active_buffer == video_buffers.buffer_a) {
        video_buffers.buffer_a_ready = true;
        video_buffers.active_buffer = video_buffers.buffer_b;
        dma_channel_transfer_to_buffer(&video_buffers.buffer_b[0]);
    } else {
        video_buffers.buffer_b_ready = true;
        video_buffers.active_buffer = video_buffers.buffer_a;
        dma_channel_transfer_to_buffer(&video_buffers.buffer_a[0]);
    }
}

// Processing loop with double-buffering
void process_with_double_buffer(void) {
    while (true) {
        // Check if a new buffer is ready
        if (video_buffers.buffer_a_ready) {
            video_buffers.processing_buffer = video_buffers.buffer_a;
            video_buffers.buffer_a_ready = false;
            process_video_line(video_buffers.processing_buffer, VIDEO_WIDTH);
        }
        
        if (video_buffers.buffer_b_ready) {
            video_buffers.processing_buffer = video_buffers.buffer_b;
            video_buffers.buffer_b_ready = false;
            process_video_line(video_buffers.processing_buffer, VIDEO_WIDTH);
        }
    }
}
                        </pre>
                    </div>

                    <div class="info-box">
                        <strong><i class="fas fa-clock"></i> Timing Critical:</strong><br>
                        With a 10MS/s sampling rate, each line has 720 samples = 72μs for processing. The double-buffer system enables seamless processing without data loss.
                    </div>
                </div>
            </div>
        </div>

        <div id="phase4" class="phase">
            <div class="phase-header">
                <h2 class="phase-title">
                    <i class="fas fa-exchange-alt phase-icon"></i>
                    Phase 4: Real-time Passthrough
                </h2>
                <p>Combining video input and output with minimal latency</p>
            </div>
            <div class="phase-content">
                <div class="section">
                    <h3>4.1 Goal: Line-by-Line Processing</h3>
                    <p>Combine the previous phases into a system that reads video line by line and immediately outputs it, without encryption.</p>

                    <div class="success-box">
                        <strong><i class="fas fa-target"></i> Performance Goals:</strong><br>
                        - Total latency: <1ms per line<br>
                        - CPU load: <50% (both cores)<br>
                        - No frame drops at 25fps<br>
                        - Seamless data transfer
                    </div>
                </div>

                <div class="section">
                    <h3>4.2 Dual-Core Architecture</h3>
                    <div class="code-block">
                        <pre>
// Dual-core configuration for optimal performance
#include "pico/multicore.h"

// Core 0: Video input and sync processing
void core0_video_input(void) {
    while (true) {
        // Wait for H-Sync
        if (h_sync_detected) {
            h_sync_detected = false;
            
            // Read new line from ADC
            read_video_line(input_buffer);
            
            // Send signal to Core 1
            multicore_fifo_push_blocking(input_buffer);
        }
        
        // V-Sync handling
        if (v_sync_detected) {
            v_sync_detected = false;
            reset_line_counter();
            multicore_fifo_push_blocking(VSYNC_MARKER);
        }
    }
}

// Core 1: Video output and DAC control
void core1_video_output(void) {
    while (true) {
        // Wait for data from Core 0
        uint32_t data = multicore_fifo_pop_blocking();
        
        if (data == VSYNC_MARKER) {
            // Handle V-Sync
            handle_vsync_output();
        } else {
            // Output video line
            uint8_t* line_buffer = (uint8_t*)data;
            output_video_line(line_buffer);
        }
    }
}

// Main program initialization
int main() {
    stdio_init_all();
    
    // Initializations
    init_adc();
    init_dac();
    init_pio();
    init_dma();
    
    // Start Core 1 (Video Output)
    multicore_launch_core1(core1_video_output);
    
    // Core 0: Video Input
    core0_video_input();
    
    return 0;
}
                        </pre>
                    </div>
                </div>

                <div class="section">
                    <h3>4.3 Buffer Strategy and Latency Management</h3>
                    <div class="code-block">
                        <pre>
// Triple-buffer system for minimal latency
typedef struct {
    uint8_t buffer[3][VIDEO_WIDTH];
    uint8_t read_index;
    uint8_t write_index;
    uint8_t processing_index;
    volatile bool buffer_ready[3];
    mutex_t buffer_mutex;
} triple_buffer_t;

static triple_buffer_t video_pipeline;

// Initialize buffer management
void init_triple_buffer(void) {
    video_pipeline.read_index = 0;
    video_pipeline.write_index = 1;
    video_pipeline.processing_index = 2;
    
    for (int i = 0; i < 3; i++) {
        video_pipeline.buffer_ready[i] = false;
    }
    
    mutex_init(&video_pipeline.buffer_mutex);
}

// Write new line to buffer (Core 0)
void write_video_line(uint8_t* data) {
    mutex_enter_blocking(&video_pipeline.buffer_mutex);
    
    memcpy(video_pipeline.buffer[video_pipeline.write_index], 
           data, VIDEO_WIDTH);
    video_pipeline.buffer_ready[video_pipeline.write_index] = true;
    
    // Rotate buffer indices
    video_pipeline.write_index = (video_pipeline.write_index + 1) % 3;
    
    mutex_exit(&video_pipeline.buffer_mutex);
}

// Read processed line from buffer (Core 1)
uint8_t* read_video_line(void) {
    uint8_t* result = NULL;
    
    mutex_enter_blocking(&video_pipeline.buffer_mutex);
    
    if (video_pipeline.buffer_ready[video_pipeline.read_index]) {
        result = video_pipeline.buffer[video_pipeline.read_index];
        video_pipeline.buffer_ready[video_pipeline.read_index] = false;
        video_pipeline.read_index = (video_pipeline.read_index + 1) % 3;
    }
    
    mutex_exit(&video_pipeline.buffer_mutex);
    
    return result;
}

// Latency measurement
void measure_latency(void) {
    static uint32_t last_timestamp = 0;
    uint32_t current_timestamp = time_us_32();
    
    if (last_timestamp != 0) {
        uint32_t latency = current_timestamp - last_timestamp;
        printf("Line Latency: %d μs\n", latency);
    }
    
    last_timestamp = current_timestamp;
}
                        </pre>
                    </div>

                    <div class="info-box">
                        <strong><i class="fas fa-tachometer-alt"></i> Performance Optimization:</strong><br>
                        The triple-buffer system allows for simultaneous reading, processing, and writing. The latency is at most 1 line (64μs) plus processing time. With DMA transfer and PIO control, the CPU load remains minimal.
                    </div>
                </div>

                <div class="section">
                    <h3>4.4 PIO Integration for Real-time Control</h3>
                    <div class="code-block">
                        <pre>
// PIO program for synchronized video processing
.program video_passthrough

; Synchronizes ADC input with DAC output
; Uses side-set for precise timing control

start:
    ; Wait for H-Sync from input
    wait 0 pin 0        ; ADC sync pin
    
    ; Start ADC sampling
    set pins, 1 [31]    ; ADC enable
    
    ; Wait for data readiness
    wait 1 pin 1        ; ADC data-ready
    
    ; Read ADC data and write to DAC
    in pins, 8          ; 8-bit data from ADC
    out pins, 8         ; 8-bit data to DAC
    
    ; Wait for end of line
    wait 1 pin 0        ; H-Sync end
    
    jmp start           ; Next line

; Timing constants
LINE_TIME = 640        ; 64μs at 10MHz
SYNC_TIME = 47         ; 4.7μs H-Sync
                        </pre>
                    </div>

                    <div class="warning-box">
                        <strong><i class="fas fa-exclamation-triangle"></i> Critical Timing Aspects:</strong><br>
                        - ADC sampling must be synchronized with video sync<br>
                        - DAC output must not overwrite ADC input<br>
                        - DMA transfer must occur between lines<br>
                        - No FIFO overflows at high data rates
                    </div>
                </div>
            </div>
        </div>

        <div id="phase5" class="phase">
            <div class="phase-header">
                <h2 class="phase-title">
                    <i class="fas fa-lock phase-icon"></i>
                    Phase 5: White Noise Stream Cipher
                </h2>
                <p>Implementation of XOR-based encryption with a synchronized PRNG</p>
            </div>
            <div class="phase-content">
                <div class="section">
                    <h3>5.1 Password Handling and Key Management</h3>
                    <div class="code-block">
                        <pre>
// Cryptographic constants and key management
#define KEY_LENGTH 64    // 64-bit key
#define PRNG_SEED_LENGTH 128

// Pre-Shared Key (set before compiling)
const uint64_t PRESHARED_KEY = 0x123456789ABCDEF0ULL;  // Example key

// Global PRNG states
typedef struct {
    uint64_t state[2];     // Xorshift128+ state
    uint64_t initial_seed; // Original seed
    uint32_t sync_counter; // Frame synchronization counter
} prng_state_t;

static prng_state_t encryption_prng;
static prng_state_t decryption_prng;

// Initialize PRNG with a key
void init_prng_with_key(prng_state_t* prng, uint64_t key) {
    // Mix key for better distribution
    prng->state[0] = key ^ 0xBF58476D1CE4E5B9ULL;
    prng->state[1] = key ^ 0x94D049BB133111EBULL;
    prng->initial_seed = key;
    prng->sync_counter = 0;
    
    // Initialize PRNG with several iterations
    for (int i = 0; i < 10; i++) {
        (void)xorshift128_plus(prng);
    }
}

// Xorshift128+ PRNG (very fast, good quality)
static inline uint64_t xorshift128_plus(prng_state_t* prng) {
    uint64_t x = prng->state[0];
    uint64_t const y = prng->state[1];
    prng->state[0] = y;
    x ^= x << 23;
    x ^= x >> 17;
    x ^= y ^ (y >> 26);
    prng->state[1] = x;
    return x + y;
}

// Encrypt a single byte
static inline uint8_t encrypt_byte(uint8_t plaintext, prng_state_t* prng) {
    uint8_t keystream = (uint8_t)(xorshift128_plus(prng) & 0xFF);
    return plaintext ^ keystream;
}

// Frame synchronization (at V-Sync)
void sync_encryption_on_vsync(prng_state_t* prng) {
    // Reset PRNG to initial state
    init_prng_with_key(prng, prng->initial_seed);
    prng->sync_counter++;
    
    // Optional: Slightly change seed after each frame
    if (prng->sync_counter % 60 == 0) {  // Every 60 frames (2 seconds)
        prng->initial_seed ^= 0xAAAAAAAA55555555ULL;
    }
}
                        </pre>
                    </div>

                    <div class="warning-box">
                        <strong><i class="fas fa-key"></i> Security Note:</strong><br>
                        The Pre-Shared Key must be set in the code before compilation. The transmitter and receiver must use the exact same key. The key should be generated from a cryptographically secure source.
                    </div>
                </div>

                <div class="section">
                    <h3>5.2 Encryption Kernel</h3>
                    <div class="code-block">
                        <pre>
// Highly optimized encryption functions
// Processes entire video lines in one pass

// Encryption function for transmitter
void encrypt_video_line_sender(uint8_t* line_data, uint length) {
    // Fast XOR encryption with PRNG keystream
    for (uint i = 0; i < length; i += 8) {
        // Generate 64-bit keystream
        uint64_t keystream = xorshift128_plus(&encryption_prng);
        
        // Encrypt 8 bytes at once
        if (i + 8 <= length) {
            uint64_t* data_ptr = (uint64_t*)&line_data[i];
            *data_ptr ^= keystream;
        } else {
            // Encrypt remaining bytes individually
            uint8_t* key_bytes = (uint8_t*)&keystream;
            for (uint j = i; j < length; j++) {
                line_data[j] ^= key_bytes[j - i];
            }
        }
    }
}

// Decryption function for receiver
void decrypt_video_line_receiver(uint8_t* line_data, uint length) {
    // Identical function to encryption (XOR is symmetric)
    encrypt_video_line_sender(line_data, length);  // Reuse the function
}

// Alternative: Byte-wise encryption for smaller buffers
void encrypt_video_line_bytewise(uint8_t* line_data, uint length) {
    for (uint i = 0; i < length; i++) {
        line_data[i] ^= (uint8_t)xorshift128_plus(&encryption_prng);
    }
}

// Fast 32-bit version for better performance
void encrypt_video_line_32bit(uint8_t* line_data, uint length) {
    uint32_t* data_32 = (uint32_t*)line_data;
    uint len_32 = length / 4;
    
    for (uint i = 0; i < len_32; i++) {
        uint32_t keystream = (uint32_t)xorshift128_plus(&encryption_prng);
        data_32[i] ^= keystream;
    }
    
    // Remaining bytes
    uint remainder = length % 4;
    if (remainder > 0) {
        uint8_t* remaining_data = line_data + (len_32 * 4);
        for (uint i = 0; i < remainder; i++) {
            remaining_data[i] ^= (uint8_t)xorshift128_plus(&encryption_prng);
        }
    }
}
                        </pre>
                    </div>
                </div>

                <div class="section">
                    <h3>5.3 Frame Synchronization Logic</h3>
                    <div class="code-block">
                        <pre>
// Critical synchronization functions
// MUST be called on every V-Sync

// Transmitter synchronization
void sender_vsync_handler(void) {
    // Stop current processing
    dma_channel_abort(ADC_DMA_CHAN);
    
    // Resynchronize PRNG
    sync_encryption_on_vsync(&encryption_prng);
    
    // Reset counter
    current_line = 0;
    encryption_prng.sync_counter++;
    
    // Signal new frame
    frame_sync_flag = true;
    
    // Optional: Logging for debugging
    if (debug_mode) {
        printf("Sender V-Sync: Frame %d\n", encryption_prng.sync_counter);
    }
}

// Receiver synchronization
void receiver_vsync_handler(void) {
    // Stop current output
    dma_channel_abort(DAC_DMA_CHAN);
    
    // Resynchronize PRNG (MUST match transmitter)
    sync_encryption_on_vsync(&decryption_prng);
    
    // Reset counter
    current_line = 0;
    decryption_prng.sync_counter++;
    
    // Signal new frame
    frame_sync_flag = true;
    
    // Optional: Sync error detection
    if (abs(decryption_prng.sync_counter - encryption_prng.sync_counter) > 1) {
        // Sync error detected
        handle_sync_error();
    }
}

// Sync error handling
void handle_sync_error(void) {
    // Attempt resynchronization
    decryption_prng.sync_counter = encryption_prng.sync_counter;
    
    // Set both PRNGs to the same state
    init_prng_with_key(&decryption_prng, PRESHARED_KEY);
    init_prng_with_key(&encryption_prng, PRESHARED_KEY);
    
    // Count sync errors
    sync_error_count++;
    
    if (debug_mode) {
        printf("Sync error fixed, counter: %d\n", sync_error_count);
    }
}

// Check synchronization status
bool check_sync_status(void) {
    return (encryption_prng.sync_counter == decryption_prng.sync_counter) &&
           (sync_error_count == 0);
}
                        </pre>
                    </div>

                    <div class="warning-box">
                        <strong><i class="fas fa-exclamation-triangle"></i> CRITICAL:</strong><br>
                        The synchronization logic is the heart of the system. Every V-Sync MUST reset both PRNGs to the exact same state. A single error will lead to permanent decryption failure.
                    </div>
                </div>

                <div class="section">
                    <h3>5.4 Integration into Video Processing</h3>
                    <div class="code-block">
                        <pre>
// Complete video processing with encryption
// Transmitter side
void process_video_line_sender(uint8_t* line_data, uint length) {
    // 1. Read video data from ADC (already done)
    
    // 2. Apply encryption
    encrypt_video_line_32bit(line_data, length);
    
    // 3. Place encrypted data in output buffer
    memcpy(tx_buffer, line_data, length);
    
    // 4. Signal ready for output
    tx_buffer_ready = true;
}

// Receiver side
void process_video_line_receiver(uint8_t* line_data, uint length) {
    // 1. Receive encrypted data
    memcpy(rx_buffer, line_data, length);
    
    // 2. Apply decryption
    decrypt_video_line_receiver(rx_buffer, length);
    
    // 3. Output cleaned data
    output_video_line(rx_buffer, length);
}

// Main processing loop with encryption
void encrypted_video_loop(void) {
    while (true) {
        // Transmitter processing (Core 0)
        if (new_line_available_sender()) {
            uint8_t* line_data = get_input_line_buffer();
            process_video_line_sender(line_data, VIDEO_WIDTH);
        }
        
        // Receiver processing (Core 1)
        if (new_line_available_receiver()) {
            uint8_t* line_data = get_received_line_buffer();
            process_video_line_receiver(line_data, VIDEO_WIDTH);
        }
        
        // V-Sync handling
        if (vsync_detected) {
            sender_vsync_handler();
            // Receiver is synchronized via radio link
        }
    }
}
                        </pre>
                    </div>

                    <div class="info-box">
                        <strong><i class="fas fa-shield-alt"></i> Security Features:</strong><br>
                        - One-Time-Pad emulation through frame-based PRNG resynchronization<br>
                        - Deterministic keystream generation<br>
                        - No storage of the keystream (only state)<br>
                        - Frame synchronization as an additional security layer
                    </div>
                </div>
            </div>
        </div>

        <div id="phase6" class="phase">
            <div class="phase-header">
                <h2 class="phase-title">
                    <i class="fas fa-cogs phase-icon"></i>
                    Phase 6: Final System Integration
                </h2>
                <p>Complete transmitter and receiver firmware with test framework</p>
            </div>
            <div class="phase-content">
                <div class="section">
                    <h3>6.1 Transmitter Firmware</h3>
                    <div class="code-block">
                        <pre>
// PicoCrypt FPV - Transmitter Firmware
// Complete implementation with all components

#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/dma.h"
#include "hardware/adc.h"
#include "pico/multicore.h"

// ===== CONFIGURATION =====
#define PRESHARED_KEY   0x123456789ABCDEF0ULL  // 64-bit key
#define VIDEO_WIDTH     720
#define VIDEO_HEIGHT    576
#define SAMPLE_RATE     10000000  // 10MS/s

// ===== GLOBAL VARIABLES =====
static uint8_t video_buffer[VIDEO_WIDTH];
static uint8_t encrypted_buffer[VIDEO_WIDTH];
static prng_state_t sender_prng;
static volatile bool new_frame = false;
static volatile uint32_t line_counter = 0;

// ===== CRYPTOGRAPHY =====
void init_encryption(void) {
    init_prng_with_key(&sender_prng, PRESHARED_KEY);
}

void encrypt_line(uint8_t* input, uint8_t* output, uint length) {
    // Fast 32-bit XOR encryption
    uint32_t* in_32 = (uint32_t*)input;
    uint32_t* out_32 = (uint32_t*)output;
    uint len_32 = length / 4;
    
    for (uint i = 0; i < len_32; i++) {
        uint32_t keystream = (uint32_t)xorshift128_plus(&sender_prng);
        out_32[i] = in_32[i] ^ keystream;
    }
    
    // Remaining bytes
    uint remainder = length % 4;
    if (remainder > 0) {
        uint8_t* in_rem = input + (len_32 * 4);
        uint8_t* out_rem = output + (len_32 * 4);
        for (uint i = 0; i < remainder; i++) {
            out_rem[i] = in_rem[i] ^ (uint8_t)xorshift128_plus(&sender_prng);
        }
    }
}

// ===== VIDEO INPUT (Core 0) =====
void core0_video_input(void) {
    // ADC initialization
    adc_init();
    adc_gpio_init(26);  // ADC Pin 26
    adc_select_input(0);
    adc_set_clkdiv(0);  // Max Speed
    
    // DMA for ADC
    int adc_dma_chan = dma_claim_unused_channel(true);
    dma_channel_config c = dma_channel_get_default_config(adc_dma_chan);
    channel_config_set_transfer_data_size(&c, DMA_SIZE_8);
    channel_config_set_read_increment(&c, false);
    channel_config_set_write_increment(&c, true);
    channel_config_set_dreq(&c, DREQ_ADC);
    
    // PIO for sync detection
    PIO pio = pio0;
    uint sm = pio_claim_unused_sm(pio, true);
    init_pio_sync_detection(pio, sm);
    
    while (true) {
        // Wait for H-Sync
        if (pio_interrupt_get(pio, sm)) {
            pio_interrupt_clear(pio, sm);
            
            // Read new line
            dma_channel_configure(adc_dma_chan, &c, 
                video_buffer, &adc_hw->fifo, VIDEO_WIDTH, true);
            
            // Wait for DMA completion
            dma_channel_wait_for_finish_blocking(adc_dma_chan);
            
            // Encrypt
            encrypt_line(video_buffer, encrypted_buffer, VIDEO_WIDTH);
            
            // Send to Core 1
            multicore_fifo_push_blocking((uint32_t)encrypted_buffer);
            
            line_counter++;
        }
        
        // V-Sync handling
        if (pio_interrupt_get(pio, 1)) {
            pio_interrupt_clear(pio, 1);
            
            // Resynchronize PRNG
            sync_encryption_on_vsync(&sender_prng);
            line_counter = 0;
            new_frame = true;
            
            // V-Sync signal to Core 1
            multicore_fifo_push_blocking(VSYNC_MARKER);
        }
    }
}

// ===== VIDEO OUTPUT (Core 1) =====
void core1_video_output(void) {
    // R-2R DAC initialization
    init_r2r_dac();
    
    // PIO for video output
    PIO pio = pio1;
    uint sm = pio_claim_unused_sm(pio, true);
    init_pio_video_output(pio, sm);
    
    // DMA for DAC output
    int dac_dma_chan = dma_claim_unused_channel(true);
    dma_channel_config c = dma_channel_get_default_config(dac_dma_chan);
    channel_config_set_transfer_data_size(&c, DMA_SIZE_8);
    channel_config_set_read_increment(&c, true);
    channel_config_set_write_increment(&c, false);
    channel_config_set_dreq(&c, DREQ_PIO1_TX0);
    
    while (true) {
        uint32_t data = multicore_fifo_pop_blocking();
        
        if (data == VSYNC_MARKER) {
            // Handle V-Sync output
            handle_vsync_output();
        } else {
            // Receive encrypted data
            uint8_t* encrypted_data = (uint8_t*)data;
            
            // Output directly to DAC (no further processing on transmitter)
            dma_channel_configure(dac_dma_chan, &c,
                &pio1_hw->txf[0], encrypted_data, VIDEO_WIDTH, true);
        }
    }
}

// ===== MAIN PROGRAM =====
int main() {
    stdio_init_all();
    
    // Initializations
    init_encryption();
    
    // Start Core 1
    multicore_launch_core1(core1_video_output);
    
    // Core 0: Video Input
    core0_video_input();
    
    return 0;
}
                        </pre>
                    </div>
                </div>

                <div class="section">
                    <h3>6.2 Receiver Firmware</h3>
                    <div class="code-block">
                        <pre>
// PicoCrypt FPV - Receiver Firmware
// Almost identical to transmitter, but with decryption

#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/dma.h"
#include "pico/multicore.h"

// ===== CONFIGURATION =====
#define PRESHARED_KEY   0x123456789ABCDEF0ULL  // MUST match transmitter!
#define VIDEO_WIDTH     720
#define VIDEO_HEIGHT    576

// ===== CRYPTOGRAPHY =====
static prng_state_t receiver_prng;

void init_decryption(void) {
    init_prng_with_key(&receiver_prng, PRESHARED_KEY);
}

void decrypt_line(uint8_t* input, uint8_t* output, uint length) {
    // Identical function to encryption (XOR is symmetric)
    uint32_t* in_32 = (uint32_t*)input;
    uint32_t* out_32 = (uint32_t*)output;
    uint len_32 = length / 4;
    
    for (uint i = 0; i < len_32; i++) {
        uint32_t keystream = (uint32_t)xorshift128_plus(&receiver_prng);
        out_32[i] = in_32[i] ^ keystream;
    }
    
    // Remaining bytes
    uint remainder = length % 4;
    if (remainder > 0) {
        uint8_t* in_rem = input + (len_32 * 4);
        uint8_t* out_rem = output + (len_32 * 4);
        for (uint i = 0; i < remainder; i++) {
            out_rem[i] = in_rem[i] ^ (uint8_t)xorshift128_plus(&receiver_prng);
        }
    }
}

// ===== DATA RECEPTION (Core 0) =====
void core0_data_receiver(void) {
    // Video input from transmitter (via radio link)
    // Radio communication would happen here
    // For testing purposes: Direct connection
    
    while (true) {
        // Wait for data from transmitter
        // (In a real implementation: SPI, UART, or radio module)
        
        // Example: receive data from transmitter
        uint8_t* received_data = receive_video_data();
        
        // Forward to Core 1
        multicore_fifo_push_blocking((uint32_t)received_data);
    }
}

// ===== DECRYPTION & OUTPUT (Core 1) =====
void core1_decrypt_output(void) {
    uint8_t decrypted_buffer[VIDEO_WIDTH];
    
    // R-2R DAC initialization
    init_r2r_dac();
    
    // PIO for video output
    PIO pio = pio1;
    uint sm = pio_claim_unused_sm(pio, true);
    init_pio_video_output(pio, sm);
    
    // DMA for DAC output
    int dac_dma_chan = dma_claim_unused_channel(true);
    dma_channel_config c = dma_channel_get_default_config(dac_dma_chan);
    channel_config_set_transfer_data_size(&c, DMA_SIZE_8);
    channel_config_set_read_increment(&c, true);
    channel_config_set_write_increment(&c, false);
    channel_config_set_dreq(&c, DREQ_PIO1_TX0);
    
    while (true) {
        uint32_t data = multicore_fifo_pop_blocking();
        
        if (data == VSYNC_MARKER) {
            // Resynchronize on V-Sync
            sync_encryption_on_vsync(&receiver_prng);
            handle_vsync_output();
        } else {
            // Receive encrypted data
            uint8_t* encrypted_data = (uint8_t*)data;
            
            // Decrypt
            decrypt_line(encrypted_data, decrypted_buffer, VIDEO_WIDTH);
            
            // Output decrypted data
            dma_channel_configure(dac_dma_chan, &c,
                &pio1_hw->txf[0], decrypted_buffer, VIDEO_WIDTH, true);
        }
    }
}

// ===== MAIN PROGRAM =====
int main() {
    stdio_init_all();
    
    // Initializations
    init_decryption();
    
    // Start Core 1 (Decryption & Output)
    multicore_launch_core1(core1_decrypt_output);
    
    // Core 0: Data Reception
    core0_data_receiver();
    
    return 0;
}
                        </pre>
                    </div>
                </div>

                <div class="section">
                    <h3>6.3 Test Framework and Debugging</h3>
                    <div class="code-block">
                        <pre>
// Test and debug functions for the PicoCrypt FPV System

// Performance monitoring
typedef struct {
    uint32_t frame_count;
    uint32_t line_count;
    uint32_t sync_errors;
    uint32_t encryption_errors;
    uint32_t max_latency_us;
    uint32_t avg_latency_us;
    uint64_t total_processing_time;
} performance_stats_t;

static performance_stats_t system_stats;

// Initialize performance tracking
void init_performance_monitoring(void) {
    memset(&system_stats, 0, sizeof(system_stats));
}

// Measure latency per line
void measure_line_latency(uint32_t start_time) {
    uint32_t end_time = time_us_32();
    uint32_t latency = end_time - start_time;
    
    system_stats.total_processing_time += latency;
    system_stats.line_count++;
    
    if (latency > system_stats.max_latency_us) {
        system_stats.max_latency_us = latency;
    }
    
    // Calculate average every 100 lines
    if (system_stats.line_count % 100 == 0) {
        system_stats.avg_latency_us = system_stats.total_processing_time / 100;
        system_stats.total_processing_time = 0;
    }
}

// Update frame statistics
void update_frame_stats(void) {
    system_stats.frame_count++;
    
    // Output every 60 frames (approx. every 2 seconds)
    if (system_stats.frame_count % 60 == 0) {
        print_performance_report();
    }
}

// Print performance report
void print_performance_report(void) {
    printf("\n=== PicoCrypt FPV Performance Report ===\n");
    printf("Frames processed: %d\n", system_stats.frame_count);
    printf("Lines processed: %d\n", system_stats.line_count);
    printf("Maximum latency: %d μs\n", system_stats.max_latency_us);
    printf("Average latency: %d μs\n", system_stats.avg_latency_us);
    printf("Sync errors: %d\n", system_stats.sync_errors);
    printf("Encryption errors: %d\n", system_stats.encryption_errors);
    printf("========================================\n\n");
}

// Test pattern generation for debugging
void generate_test_pattern(uint8_t* buffer, uint pattern_type) {
    switch (pattern_type) {
        case 0:  // Color bars
            for (int i = 0; i < VIDEO_WIDTH; i++) {
                int bar = (i * 8) / VIDEO_WIDTH;
                buffer[i] = 0xFF >> bar;
            }
            break;
            
        case 1:  // Grayscale wedge
            for (int i = 0; i < VIDEO_WIDTH; i++) {
                buffer[i] = (i * 255) / VIDEO_WIDTH;
            }
            break;
            
        case 2:  // Checkerboard pattern
            for (int y = 0; y < 10; y++) {
                for (int x = 0; x < VIDEO_WIDTH; x++) {
                    int pos = y * VIDEO_WIDTH + x;
                    buffer[pos] = ((x/10) + (y/10)) % 2 ? 0xFF : 0x00;
                }
            }
            break;
            
        default:  // White
            memset(buffer, 0xFF, VIDEO_WIDTH);
    }
}

// Encryption test
bool test_encryption_consistency(void) {
    uint8_t test_data[256];
    uint8_t encrypted[256];
    uint8_t decrypted[256];
    
    // Generate test data
    for (int i = 0; i < 256; i++) {
        test_data[i] = i;
    }
    
    // Encrypt
    prng_state_t test_prng;
    init_prng_with_key(&test_prng, PRESHARED_KEY);
    
    for (int i = 0; i < 256; i++) {
        encrypted[i] = test_data[i] ^ (uint8_t)xorshift128_plus(&test_prng);
    }
    
    // Reset and decrypt
    init_prng_with_key(&test_prng, PRESHARED_KEY);
    
    for (int i = 0; i < 256; i++) {
        decrypted[i] = encrypted[i] ^ (uint8_t)xorshift128_plus(&test_prng);
    }
    
    // Compare
    bool success = (memcmp(test_data, decrypted, 256) == 0);
    
    printf("Encryption Test: %s\n", success ? "OK" : "FAIL");
    
    if (!success) {
        system_stats.encryption_errors++;
    }
    
    return success;
}

// System self-test
void run_system_selftest(void) {
    printf("Starting PicoCrypt FPV self-test...\n");
    
    // Test 1: Encryption consistency
    bool crypto_ok = test_encryption_consistency();
    
    // Test 2: ADC/DAC connection
    bool adc_dac_ok = test_adc_dac_connection();
    
    // Test 3: PIO timing
    bool pio_ok = test_pio_timing();
    
    // Test 4: DMA transfer
    bool dma_ok = test_dma_transfer();
    
    // Test 5: Dual-core communication
    bool multicore_ok = test_multicore_comms();
    
    // Result
    printf("\n=== SELF-TEST RESULT ===\n");
    printf("Encryption: %s\n", crypto_ok ? "OK" : "FAIL");
    printf("ADC/DAC: %s\n", adc_dac_ok ? "OK" : "FAIL");
    printf("PIO Timing: %s\n", pio_ok ? "OK" : "FAIL");
    printf("DMA Transfer: %s\n", dma_ok ? "OK" : "FAIL");
    printf("Multicore: %s\n", multicore_ok ? "OK" : "FAIL");
    printf("===========================\n");
    
    if (crypto_ok && adc_dac_ok && pio_ok && dma_ok && multicore_ok) {
        printf("All tests PASSED! System ready for operation.\n");
    } else {
        printf("WARNING: Some tests FAILED!\n");
    }
}
                        </pre>
                    </div>
                </div>

                <div class="section">
                    <h3>6.4 Test Strategy and Troubleshooting</h3>
                    
                    <div class="info-box">
                        <strong><i class="fas fa-vial"></i> Step-by-Step Test Procedure:</strong>
                    </div>

                    <h4>Test Phase 1: Basic Functions</h4>
                    <ul>
                        <li><strong>Video Output Test:</strong> Color bars without encryption</li>
                        <li><strong>ADC Test:</strong> Correctly display input signal</li>
                        <li><strong>Passthrough Test:</strong> Video through the system without encryption</li>
                    </ul>

                    <h4>Test Phase 2: Encryption</h4>
                    <ul>
                        <li><strong>Static Test:</strong> Same key, both modules</li>
                        <li><strong>Dynamic Test:</strong> Moving picture with encryption</li>
                        <li><strong>Sync Test:</strong> Verify V-Sync resynchronization</li>
                    </ul>

                    <h4>Test Phase 3: System Integration</h4>
                    <ul>
                        <li><strong>Cable Test:</strong> Direct connection between transmitter and receiver</li>
                        <li><strong>Radio Test:</strong> Transmission over radio link</li>
                        <li><strong>Long-Term Test:</strong> 24h continuous operation</li>
                    </ul>

                    <div class="warning-box">
                        <strong><i class="fas fa-tools"></i> Debugging Notes:</strong><br>
                        - For sync errors: Check V-Sync signals with an oscilloscope<br>
                        - For image distortions: Compare PRNG states<br>
                        - For latency issues: Analyze DMA and PIO statistics<br>
                        - For encryption errors: Use test patterns
                    </div>

                    <div class="success-box">
                        <strong><i class="fas fa-check-circle"></i> Success Criteria:</strong><br>
                        - Stable image without artifacts<br>
                        - Correct encryption/decryption<br>
                        - Latency <1ms per line<br>
                        - No frame drops at 25fps<br>
                        - 24h continuous operation without errors
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="download-section">
        <div class="container">
            <h2><i class="fas fa-download"></i> Project Downloads</h2>
            <p>Complete project files, schematics, and documentation</p>
            <a href="#" class="download-btn"><i class="fas fa-file-code"></i> Firmware Code (C/C++)</a>
            <a href="#" class="download-btn"><i class="fas fa-microchip"></i> Schematics (KiCad)</a>
            <a href="#" class="download-btn"><i class="fas fa-book"></i> Bill of Materials</a>
            <a href="#" class="download-btn"><i class="fas fa-file-pdf"></i> Complete Documentation</a>
        </div>
    </div>

    <script>
        // Smooth scrolling for internal links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                document.querySelector(this.getAttribute('href')).scrollIntoView({
                    behavior: 'smooth'
                });
            });
        });

        // Highlight current section in TOC
        window.addEventListener('scroll', function() {
            let current = '';
            const sections = document.querySelectorAll('.phase');
            
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (pageYOffset >= sectionTop - 200) {
                    current = section.getAttribute('id');
                }
            });

            document.querySelectorAll('.toc a').forEach(link => {
                link.classList.remove('highlight');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('highlight');
                }
            });
        });
    </script>
</body>
</html>